# -*- coding: utf-8 -*-
"""Microphase_Beta.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iqC2xkNfrpuNJO6GG6r1iLD0MUap2_sc
"""

#Raw Correlation Functions !!Do not forget N,N^2,N^3
import CorrelationFunction
from CorrelationFunction import G2,G3,G4,g1,g2,g3,g4,Gamma2_p,Gamma3_p,Gamma4_p

import time

import math
import random

import numpy as np
from numpy.linalg import det,norm

import scipy as scp
from scipy.optimize import minimize,shgo,root,curve_fit
from scipy.misc import derivative
from scipy import integrate
from scipy.linalg import inv,eig

import sympy as sym
from sympy import symbols, diff
from sympy.combinatorics import Permutation
from sympy.utilities.iterables import multiset_permutations

#Fixed Parameters!
B=4
N=200
alpha=0.3
l_b=0.7*alpha**2 #Bjerrum length
#incompressible matrix
h1=np.array([-1,1])
h=np.array([[-1,1,0],[-1,0,1]])
#Blocking of chains
Bounds=np.array([0,N/B])
for i in range(1,B):
   Bounds=np.vstack((Bounds,[N*i/B,N*i/B+N/B]))
#suming index for momentums
sumk_index=[[0, 1],[0, 1, 0, 2],[0, 1, 0, 2, 0,3]]

#Sequence construction
seqa=np.zeros(B,dtype=int)   #!! B should be an even number.
for i in range(0,int(B/2)):
     seqa[i]=1
for i in range(int(B/2),B):
     seqa[i]=0
seq=np.array([p for p in multiset_permutations(seqa)])
index=[]
for i in range(1,np.shape(seq)[0]): #Revrse Order
  for j in range(0,i):
    if (seq[j] == seq[i][::-1]).all():
         index.append(i)
seq=np.delete(seq,index,axis=0)
#print(len(seq))
#print(seq)

"""Spinodal points"""
def spacing_chi(sequence,phi_p,chi_As,chi_Bs,kappa):
  success=False
  count=0

  def target(vec,seq,M):   #M is the magnification index. It will help the numerical evaluation. 
    q,chi_AB = vec
    dq=1e-6
    chi_list=np.array([chi_As,chi_Bs,chi_AB])  # chi_As,chi_Bs,phi_p,kappa are fixed when we look for q and chi_AB
    chi_av=(chi_As+chi_Bs)/2
    dchi=(chi_As-chi_Bs)/2

    matrix_2=Gamma2_p(seq,phi_p,q,Bounds,N)
    d_matrix_2=Gamma2_p(seq,phi_p,q+dq,Bounds,N)-matrix_2
    Vee=4*np.pi*l_b/(q**2+kappa**2)
    d_Vee=4*np.pi*l_b/((q+dq)**2+kappa**2)-Vee
    if phi_p ==1:
       D=matrix_2[0,0]+matrix_2[1,1]-matrix_2[0,1]-matrix_2[1,0]-2*chi_AB+Vee
       dD=(d_matrix_2[0,0]+d_matrix_2[1,1]-d_matrix_2[0,1]-d_matrix_2[1,0]+d_Vee)/dq
    else:
        phi_s=1-phi_p   
        D=((1/phi_s-2*chi_av)*(matrix_2[0,0]+matrix_2[1,1]-matrix_2[0,1]-matrix_2[1,0]- 2*chi_AB + Vee)
        +(det(matrix_2)+2*dchi*(matrix_2[0,0]-matrix_2[1,1])-2*chi_AB*matrix_2[0,1]+matrix_2[0,0]*Vee)
        -(pow(chi_AB,2)+pow(2*dchi,2)+2*dchi*Vee))
        ################################
        dD=((1/phi_s-2*chi_av)*(d_matrix_2[0,0]+d_matrix_2[1,1]-d_matrix_2[0,1]-d_matrix_2[1,0] + d_Vee)
        +(det(matrix_2+d_matrix_2)-det(matrix_2)+2*dchi*(d_matrix_2[0,0]-d_matrix_2[1,1])-2*chi_AB*d_matrix_2[0,1]+d_matrix_2[0,0]*Vee+matrix_2[0,0]*d_Vee)
        -2*dchi*d_Vee)
        dD=dD/dq
    
    return [D*M,dD*M]

  while (success == False):
      q0=0.3
      chi0=random.uniform(0.1,0.3)*0.1  
      sol = root(target, [q0, chi0],args=(sequence,100),tol=1e-4,method='hybr')  #To get successful convergence, the value of x_0 should be smaller than actuial value.  
      success=sol.success
      q_sol = abs(sol.x[0])
      chi_sol = sol.x[1]
      count=count+1
      #print(success)
      if count>5:
        q_sol=1#np.nan
        chi_sol=1#np.nan
        break
  return [q_sol,chi_sol]

"""Second order energy"""

def alpha(sequence,phi_p,q,chi_AB,chi_As,chi_Bs,kappa):
      chi_list=np.array([chi_As,chi_Bs,chi_AB])
      dchi=(chi_As-chi_Bs)/2
      Vee=4*np.pi*l_b/(q**2+kappa**2)
      if phi_p==1:
        S2_p=inv(Gamma2_p(sequence,phi_p,q,Bounds,N))
        value=N*(np.sum(S2_p)/det(S2_p)-2*chi_AB+4*np.pi*l_b/(q**2+kappa**2))
      else:  
        phi_s=1-phi_p        
        hGamma2h=Gamma2_p(sequence,phi_p,q,Bounds,N)+np.ones((2,2))*(1/phi_s-chi_As-chi_Bs)+np.array([[-2*dchi,chi_AB],[chi_AB,2*dchi+Vee]])
        w,v=eig(hGamma2h)
        hGamma2h_g=np.einsum('i,j,ij',v[:,0],v[:,0],hGamma2h)
        value=N*hGamma2h_g
      return value
      
def eigenvector(sequence,phi_p,q,chi_AB,chi_As,chi_Bs,kappa):
      chi_list=np.array([chi_As,chi_Bs,chi_AB])
      dchi=(chi_As-chi_Bs)/2
      Vee=4*np.pi*l_b/(q**2+kappa**2)
      if phi_p==1:
        v=1
      else:  
        phi_s=1-phi_p
        hGamma2h=Gamma2_p(sequence,phi_p,q,Bounds,N)+np.ones((2,2))*(1/phi_s-chi_As-chi_Bs)+np.array([[-2*dchi,chi_AB],[chi_AB,2*dchi+Vee]])
        w,v=eig(hGamma2h)
        v=v[:,np.argsort(w)]
      return v

def eigenvalue(sequence,phi_p,q,chi_AB,chi_As,chi_Bs,kappa):
      chi_list=np.array([chi_As,chi_Bs,chi_AB])
      dchi=(chi_As-chi_Bs)/2
      Vee=4*np.pi*l_b/(q**2+kappa**2)
      if phi_p==1:
        w=0
      else:  
        phi_s=1-phi_p
        hGamma2h=Gamma2_p(sequence,phi_p,q,Bounds,N)+np.ones((2,2))*(1/phi_s-chi_As-chi_Bs)+np.array([[-2*dchi,chi_AB],[chi_AB,2*dchi+Vee]])
        w,v=eig(hGamma2h)
        w=np.sort(w)
        if np.max(w)<0:
          print('error_negative')
      return w

"""Thrid and Fourth order"""

def Matrix3_1(sequence,q):
  k1=q*np.array([1,1,0])/np.sqrt(2)
  k2=q*np.array([-1,1,0])/np.sqrt(2)
  k3=q*np.array([0,1,1])/np.sqrt(2)
  k4=q*np.array([0,1,-1])/np.sqrt(2)
  k5=q*np.array([1,0,1])/np.sqrt(2)
  k6=q*np.array([1,0,-1])/np.sqrt(2)
  klist=np.array([k2,-k3,k5])
  matrix=Gamma3_p(sequence,1.0,klist,Bounds,N)
  return matrix

def Matrix3_0(sequence,q):
  k1=q*np.array([1,1,0])/np.sqrt(2)
  k2=q*np.array([-1,1,0])/np.sqrt(2)
  k3=q*np.array([0,1,1])/np.sqrt(2)
  k4=q*np.array([0,1,-1])/np.sqrt(2)
  k5=q*np.array([1,0,1])/np.sqrt(2)
  k6=q*np.array([1,0,-1])/np.sqrt(2)
  klist=np.array([k2,-k2,k2-k2])
  matrix=Gamma3_p(sequence,1.0,klist,Bounds,N)
  return matrix

def Matrix3_4(sequence,q):
  k1=q*np.array([1,1,0])/np.sqrt(2)
  k2=q*np.array([-1,1,0])/np.sqrt(2)
  k3=q*np.array([0,1,1])/np.sqrt(2)
  k4=q*np.array([0,1,-1])/np.sqrt(2)
  k5=q*np.array([1,0,1])/np.sqrt(2)
  k6=q*np.array([1,0,-1])/np.sqrt(2)
  klist=np.array([k2,k2,-k2-k2])
  matrix=Gamma3_p(sequence,1.0,klist,Bounds,N)
  return matrix 

def Matrix3_3(sequence,q):
  k1=q*np.array([1,1,0])/np.sqrt(2)
  k2=q*np.array([-1,1,0])/np.sqrt(2)
  k3=q*np.array([0,1,1])/np.sqrt(2)
  k4=q*np.array([0,1,-1])/np.sqrt(2)
  k5=q*np.array([1,0,1])/np.sqrt(2)
  k6=q*np.array([1,0,-1])/np.sqrt(2)
  klist=np.array([k1,k3,-k1-k3])
  matrix=Gamma3_p(sequence,1.0,klist,Bounds,N)
  return matrix

def Matrix3_2(sequence,q):
  k1=q*np.array([1,1,0])/np.sqrt(2)
  k2=q*np.array([-1,1,0])/np.sqrt(2)
  k3=q*np.array([0,1,1])/np.sqrt(2)
  k4=q*np.array([0,1,-1])/np.sqrt(2)
  k5=q*np.array([1,0,1])/np.sqrt(2)
  k6=q*np.array([1,0,-1])/np.sqrt(2)
  klist=np.array([k1,k2,-k1-k2])
  matrix=Gamma3_p(sequence,1.0,klist,Bounds,N)
  return matrix 
def Matrix4_00(sequence,q):
  k1=q*np.array([1,1,0])/np.sqrt(2)
  k2=q*np.array([-1,1,0])/np.sqrt(2)
  k3=q*np.array([0,1,1])/np.sqrt(2)
  k4=q*np.array([0,1,-1])/np.sqrt(2)
  k5=q*np.array([1,0,1])/np.sqrt(2)
  k6=q*np.array([1,0,-1])/np.sqrt(2)
  klist=np.array([k2,-k2,k2,-k2])
  matrix=Gamma4_p(sequence,1.0,klist,Bounds,N)
  return matrix

def Matrix4_01(sequence,q):
  k1=q*np.array([1,1,0])/np.sqrt(2)
  k2=q*np.array([-1,1,0])/np.sqrt(2)
  k3=q*np.array([0,1,1])/np.sqrt(2)
  k4=q*np.array([0,1,-1])/np.sqrt(2)
  k5=q*np.array([1,0,1])/np.sqrt(2)
  k6=q*np.array([1,0,-1])/np.sqrt(2)
  klist=np.array([k3,-k3,k1,-k1])
  matrix=Gamma4_p(sequence,1.0,klist,Bounds,N)
  return matrix  

def Matrix4_02(sequence,q):
  k1=q*np.array([1,1,0])/np.sqrt(2)
  k2=q*np.array([-1,1,0])/np.sqrt(2)
  k3=q*np.array([0,1,1])/np.sqrt(2)
  k4=q*np.array([0,1,-1])/np.sqrt(2)
  k5=q*np.array([1,0,1])/np.sqrt(2)
  k6=q*np.array([1,0,-1])/np.sqrt(2)
  klist=np.array([k1,-k1,k2,-k2])
  matrix=Gamma4_p(sequence,1.0,klist,Bounds,N)
  return matrix

def Matrix4_12(sequence,q):
  k1=q*np.array([1,1,0])/np.sqrt(2)
  k2=q*np.array([-1,1,0])/np.sqrt(2)
  k3=q*np.array([0,1,1])/np.sqrt(2)
  k4=q*np.array([0,1,-1])/np.sqrt(2)
  k5=q*np.array([1,0,1])/np.sqrt(2)
  k6=q*np.array([1,0,-1])/np.sqrt(2)
  klist=np.array([-k1,k2,k5,k6])
  matrix=Gamma4_p(sequence,1.0,klist,Bounds,N)
  return matrix

#k1=q*np.array([1,1,0])/np.sqrt(2)
#k2=q*np.array([-1,1,0])/np.sqrt(2)
#k3=q*np.array([0,1,1])/np.sqrt(2)
#k4=q*np.array([0,1,-1])/np.sqrt(2)
#k5=q*np.array([1,0,1])/np.sqrt(2)
#k6=q*np.array([1,0,-1])/np.sqrt(2)
def Gamma3g_1(matrix3_1,phi_p,eigv):
    if phi_p == 1:
      value=np.einsum('i,j,k,ijk',h1,h1,h1,matrix3_1)  
    else:
      phi_s=1-phi_p
      hhhGamma3=matrix3_1/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2) 
      value=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,0],hhhGamma3)
    return value   
def Gamma4g_00(matrix4_00,matrix3_0,matrix3_4,phi_p,eigv,eigvalue):

  #klist=np.array([k2,-k2,k2,-k2])
  if phi_p == 1:
    hhhhGamma4_00=matrix4_00
    value=np.einsum('i,j,k,l,ijkl',h1,h1,h1,h1,hhhhGamma4_00)
  else:  
    phi_s=1-phi_p
    hhhhGamma4_00=matrix4_00/pow(phi_p,3)+np.ones((2,2,2,2))*2/pow(phi_s,3) 
    value_1=np.einsum('i,j,k,l,ijkl',eigv[:,0],eigv[:,0],eigv[:,0],eigv[:,0],hhhhGamma4_00)


    #p1,p2,p3,p4=klist   
    hhhGamma3_p1p2=matrix3_0/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2) 
    hhhGamma3_p3p4=matrix3_0/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)  
    A_1=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p2)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p3p4)
    hhhGamma3_p1p3=matrix3_4/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2) 
    hhhGamma3_p2p4=matrix3_4/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)  
    A_2=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p3)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p2p4)
    hhhGamma3_p1p4=matrix3_0/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2) 
    hhhGamma3_p2p3=matrix3_0/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)  
    A_3=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p4)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p2p3)
    Delta_Gamma4_00=A_1+A_2+A_3
    value=value_1-Delta_Gamma4_00
  return value

def Gamma4g_01(matrix4_01,matrix3_0,matrix3_3,matrix3_1,phi_p,eigv,eigvalue):
  
  #klist=np.array([k3,-k3,k1,-k1])
  if phi_p == 1:    
    hhhhGamma4_01=matrix4_01
    value=np.einsum('i,j,k,l,ijkl',h1,h1,h1,h1,hhhhGamma4_01)
  else:  
    phi_s=1-phi_p
    
    hhhhGamma4_01=matrix4_01/pow(phi_p,3)+np.ones((2,2,2,2))*2/pow(phi_s,3) 
    value_1=np.einsum('i,j,k,l,ijkl',eigv[:,0],eigv[:,0],eigv[:,0],eigv[:,0],hhhhGamma4_01)
    
    #p1,p2,p3,p4=klist
    
    hhhGamma3_p1p2=matrix3_0/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    hhhGamma3_p3p4=matrix3_0/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    A_1=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p2)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p3p4)    
    hhhGamma3_p1p3=matrix3_3/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    hhhGamma3_p2p4=matrix3_3/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    A_2=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p3)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p2p4) 
    hhhGamma3_p1p4=matrix3_1/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    hhhGamma3_p2p3=matrix3_1/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    A_3=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p4)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p2p3)
    Delta_Gamma4_01=A_1+A_2#+A_3  
    value=(value_1-Delta_Gamma4_01)
  return value

def Gamma4g_02(matrix4_02,matrix3_0,matrix3_2,phi_p,eigv,eigvalue):
  
  #klist=np.array([k1,-k1,k2,-k2])

  if phi_p == 1:
    hhhhGamma4_02=matrix4_02
    value=np.einsum('i,j,k,l,ijkl',h1,h1,h1,h1,hhhhGamma4_02)
  else:  
    phi_s=1-phi_p
    hhhhGamma4_02=matrix4_02/pow(phi_p,3)+np.ones((2,2,2,2))*2/pow(phi_s,3)
    value_1=np.einsum('i,j,k,l,ijkl',eigv[:,0],eigv[:,0],eigv[:,0],eigv[:,0],hhhhGamma4_02)

    #p1,p2,p3,p4=klist

    hhhGamma3_p1p2=matrix3_0/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    hhhGamma3_p3p4=matrix3_0/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    A_1=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p2)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p3p4)
    hhhGamma3_p1p3=matrix3_2/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    hhhGamma3_p2p4=matrix3_2/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    A_2=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p3)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p2p4)
    hhhGamma3_p1p4=matrix3_2/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    hhhGamma3_p2p3=matrix3_2/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    A_3=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p4)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p2p3)
    Delta_Gamma4_02=A_1+A_2+A_3
    value=(value_1-Delta_Gamma4_02)

  return value

def Gamma4g_12(matrix4_12,matrix3_2,matrix3_1,phi_p,eigv,eigvalue):
 
  # klist=np.array([-k1,k2,k5,k6])  
  if phi_p == 1:
    hhhhGamma4_12=matrix4_12
    value=np.einsum('i,j,k,l,ijkl',h1,h1,h1,h1,hhhhGamma4_12)
  else:  
    phi_s=1-phi_p  
    hhhhGamma4_12=matrix4_12/pow(phi_p,3)+np.ones((2,2,2,2))*2/pow(phi_s,3)
    value_1=np.einsum('i,j,k,l,ijkl',eigv[:,0],eigv[:,0],eigv[:,0],eigv[:,0],hhhhGamma4_12)

    # p1,p2,p3,p4=klist

    hhhGamma3_p1p2=matrix3_2/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    hhhGamma3_p3p4=matrix3_2/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    A_1=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p2)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p3p4)    
    hhhGamma3_p1p3=matrix3_1/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    hhhGamma3_p2p4=matrix3_1/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    A_2=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p3)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p2p4)
    hhhGamma3_p1p4=matrix3_1/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    hhhGamma3_p2p3=matrix3_1/pow(phi_p,2)-np.ones((2,2,2))/pow(phi_s,2)
    A_3=np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p1p4)*pow(abs(eigvalue[1]),-1)*np.einsum('i,j,k,ijk',eigv[:,0],eigv[:,0],eigv[:,1],hhhGamma3_p2p3)
    Delta_Gamma4_12=A_1+A_2+A_3
    value=(value_1-Delta_Gamma4_12)
  return value

"""Find Phase"""

def microphase(alpha,beta_1,gamma_1,beta_3,gamma_3,beta_6,gamma_6):  #Betas need to be positve
    criteria_1=9*beta_1**2-32*alpha*gamma_1
    criteria_3=9*beta_3**2-32*alpha*gamma_3
    criteria_6=9*beta_6**2-32*alpha*gamma_6
    if criteria_1 < 0:
       value_1=0
    else:
       value_1=pow(beta_1+np.sqrt(criteria_1),3)*(beta_1-np.sqrt(criteria_1))/(pow(2,12)*pow(gamma_1,3))

    if criteria_3 < 0:
       value_3=0
    else:
       value_3=pow(beta_3+np.sqrt(criteria_3),3)*(beta_3-np.sqrt(criteria_3))/(pow(2,12)*pow(gamma_3,3))

    if criteria_6 < 0:
       value_6=0
    else:
       value_6=pow(beta_6+np.sqrt(criteria_6),3)*(beta_6-np.sqrt(criteria_6))/(pow(2,12)*pow(gamma_6,3))
    temporal=np.array([0,value_1,value_3,value_6])
    #print(temporal)
    value=np.argmin(temporal)
    return value

"""Scenarios"""

#Spinodal points
chi_As=0.5+0.2
chi_Bs=0.5-0.2

Kappas=np.arange(7,10.01,0.01)#np.array([2,3])
Phi_s=np.arange(0.085,0.090,0.001)#np.array([0.07,0.08])
sequence=seq[3]

q_Storage=np.zeros((len(Kappas),len(Phi_s)))
chi_Storage=np.zeros((len(Kappas),len(Phi_s)))
for i in range(0,len(Kappas)):
  for j in range(0,len(Phi_s)):
    kappa=Kappas[i]
    phi_p=1-Phi_s[j]
    q_critical,chi_critical=spacing_chi(sequence,phi_p,chi_As,chi_Bs,kappa)
    q_Storage[i,j]=q_critical
    chi_Storage[i,j]=chi_critical

phi_s_q_Storage=np.concatenate((np.array([Phi_s]), q_Storage), axis=0)
kappa_phi_s_q_Storage=np.concatenate((np.array([np.append(0,Kappas)]).T, phi_s_q_Storage), axis=1)
np.savetxt('q_c_seq{}_S2_kappa_7_10_Phi_s_0.085_0.09.txt'.format(3),kappa_phi_s_q_Storage)

phi_s_chi_Storage=np.concatenate((np.array([Phi_s]), chi_Storage), axis=0)
kappa_phi_s_chi_Storage=np.concatenate((np.array([np.append(0,Kappas)]).T, phi_s_chi_Storage), axis=1)
np.savetxt('chi_c_seq{}_S2_kappa_7_10_Phi_s_0.085_0.09.txt'.format(3),kappa_phi_s_chi_Storage)


